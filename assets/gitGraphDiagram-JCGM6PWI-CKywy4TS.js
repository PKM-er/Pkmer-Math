import{c as U}from"./chunk-4KE642ED-B2CyjD4P.js";import{p as _}from"./treemap-KMMF4GRG-7ORZ52ND-QOKq7EC0.js";import{s as Y}from"./chunk-VSLJSFIP-C2h2No_i.js";import{m as d,e as V,j as J,G as Q,$ as X,U as Z,H as tt,p as u,a as et,i as rt,d as at,K as it,N as ot,h as E,L as nt,O as st,r as ct,w as ht}from"./mermaid.esm.min-Cf25w0Rs.js";import"./chunk-OMTJKCYW-BZ9eU5Fm.js";import"./app-CzvW4FtQ.js";var x={NORMAL:0,REVERSE:1,HIGHLIGHT:2,MERGE:3,CHERRY_PICK:4},dt=ct.gitGraph,P=d(()=>nt({...dt,...st().gitGraph}),"getConfig"),c=new Y(()=>{let e=P(),t=e.mainBranchName,i=e.mainBranchOrder;return{mainBranchName:t,commits:new Map,head:null,branchConfig:new Map([[t,{name:t,order:i}]]),branches:new Map([[t,null]]),currBranch:t,direction:"LR",seq:0,options:{}}});function O(){return ht({length:7})}d(O,"getID");function S(e,t){let i=Object.create(null);return e.reduce((o,r)=>{let a=t(r);return i[a]||(i[a]=!0,o.push(r)),o},[])}d(S,"uniqBy");var mt=d(function(e){c.records.direction=e},"setDirection"),lt=d(function(e){u.debug("options str",e),e=e?.trim(),e=e||"{}";try{c.records.options=JSON.parse(e)}catch(t){u.error("error while parsing gitGraph options",t.message)}},"setOptions"),$t=d(function(){return c.records.options},"getOptions"),gt=d(function(e){let t=e.msg,i=e.id,o=e.type,r=e.tags;u.info("commit",t,i,o,r),u.debug("Entering commit:",t,i,o,r);let a=P();i=E.sanitizeText(i,a),t=E.sanitizeText(t,a),r=r?.map(n=>E.sanitizeText(n,a));let h={id:i||c.records.seq+"-"+O(),message:t,seq:c.records.seq++,type:o??x.NORMAL,tags:r??[],parents:c.records.head==null?[]:[c.records.head.id],branch:c.records.currBranch};c.records.head=h,u.info("main branch",a.mainBranchName),c.records.commits.has(h.id)&&u.warn(`Commit ID ${h.id} already exists`),c.records.commits.set(h.id,h),c.records.branches.set(c.records.currBranch,h.id),u.debug("in pushCommit "+h.id)},"commit"),yt=d(function(e){let t=e.name,i=e.order;if(t=E.sanitizeText(t,P()),c.records.branches.has(t))throw new Error(`Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${t}")`);c.records.branches.set(t,c.records.head!=null?c.records.head.id:null),c.records.branchConfig.set(t,{name:t,order:i}),D(t),u.debug("in createBranch")},"branch"),pt=d(e=>{let t=e.branch,i=e.id,o=e.type,r=e.tags,a=P();t=E.sanitizeText(t,a),i&&(i=E.sanitizeText(i,a));let h=c.records.branches.get(c.records.currBranch),n=c.records.branches.get(t),$=h?c.records.commits.get(h):void 0,m=n?c.records.commits.get(n):void 0;if($&&m&&$.branch===t)throw new Error(`Cannot merge branch '${t}' into itself.`);if(c.records.currBranch===t){let s=new Error('Incorrect usage of "merge". Cannot merge a branch to itself');throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:["branch abc"]},s}if($===void 0||!$){let s=new Error(`Incorrect usage of "merge". Current branch (${c.records.currBranch})has no commits`);throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:["commit"]},s}if(!c.records.branches.has(t)){let s=new Error('Incorrect usage of "merge". Branch to be merged ('+t+") does not exist");throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:[`branch ${t}`]},s}if(m===void 0||!m){let s=new Error('Incorrect usage of "merge". Branch to be merged ('+t+") has no commits");throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:['"commit"']},s}if($===m){let s=new Error('Incorrect usage of "merge". Both branches have same head');throw s.hash={text:`merge ${t}`,token:`merge ${t}`,expected:["branch abc"]},s}if(i&&c.records.commits.has(i)){let s=new Error('Incorrect usage of "merge". Commit with id:'+i+" already exists, use different custom id");throw s.hash={text:`merge ${t} ${i} ${o} ${r?.join(" ")}`,token:`merge ${t} ${i} ${o} ${r?.join(" ")}`,expected:[`merge ${t} ${i}_UNIQUE ${o} ${r?.join(" ")}`]},s}let l=n||"",g={id:i||`${c.records.seq}-${O()}`,message:`merged branch ${t} into ${c.records.currBranch}`,seq:c.records.seq++,parents:c.records.head==null?[]:[c.records.head.id,l],branch:c.records.currBranch,type:x.MERGE,customType:o,customId:!!i,tags:r??[]};c.records.head=g,c.records.commits.set(g.id,g),c.records.branches.set(c.records.currBranch,g.id),u.debug(c.records.branches),u.debug("in mergeBranch")},"merge"),xt=d(function(e){let t=e.id,i=e.targetId,o=e.tags,r=e.parent;u.debug("Entering cherryPick:",t,i,o);let a=P();if(t=E.sanitizeText(t,a),i=E.sanitizeText(i,a),o=o?.map($=>E.sanitizeText($,a)),r=E.sanitizeText(r,a),!t||!c.records.commits.has(t)){let $=new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');throw $.hash={text:`cherryPick ${t} ${i}`,token:`cherryPick ${t} ${i}`,expected:["cherry-pick abc"]},$}let h=c.records.commits.get(t);if(h===void 0||!h)throw new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');if(r&&!(Array.isArray(h.parents)&&h.parents.includes(r)))throw new Error("Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit.");let n=h.branch;if(h.type===x.MERGE&&!r)throw new Error("Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified.");if(!i||!c.records.commits.has(i)){if(n===c.records.currBranch){let g=new Error('Incorrect usage of "cherryPick". Source commit is already on current branch');throw g.hash={text:`cherryPick ${t} ${i}`,token:`cherryPick ${t} ${i}`,expected:["cherry-pick abc"]},g}let $=c.records.branches.get(c.records.currBranch);if($===void 0||!$){let g=new Error(`Incorrect usage of "cherry-pick". Current branch (${c.records.currBranch})has no commits`);throw g.hash={text:`cherryPick ${t} ${i}`,token:`cherryPick ${t} ${i}`,expected:["cherry-pick abc"]},g}let m=c.records.commits.get($);if(m===void 0||!m){let g=new Error(`Incorrect usage of "cherry-pick". Current branch (${c.records.currBranch})has no commits`);throw g.hash={text:`cherryPick ${t} ${i}`,token:`cherryPick ${t} ${i}`,expected:["cherry-pick abc"]},g}let l={id:c.records.seq+"-"+O(),message:`cherry-picked ${h?.message} into ${c.records.currBranch}`,seq:c.records.seq++,parents:c.records.head==null?[]:[c.records.head.id,h.id],branch:c.records.currBranch,type:x.CHERRY_PICK,tags:o?o.filter(Boolean):[`cherry-pick:${h.id}${h.type===x.MERGE?`|parent:${r}`:""}`]};c.records.head=l,c.records.commits.set(l.id,l),c.records.branches.set(c.records.currBranch,l.id),u.debug(c.records.branches),u.debug("in cherryPick")}},"cherryPick"),D=d(function(e){if(e=E.sanitizeText(e,P()),c.records.branches.has(e)){c.records.currBranch=e;let t=c.records.branches.get(c.records.currBranch);t===void 0||!t?c.records.head=null:c.records.head=c.records.commits.get(t)??null}else{let t=new Error(`Trying to checkout branch which is not yet created. (Help try using "branch ${e}")`);throw t.hash={text:`checkout ${e}`,token:`checkout ${e}`,expected:[`branch ${e}`]},t}},"checkout");function H(e,t,i){let o=e.indexOf(t);o===-1?e.push(i):e.splice(o,1,i)}d(H,"upsert");function z(e){let t=e.reduce((r,a)=>r.seq>a.seq?r:a,e[0]),i="";e.forEach(function(r){r===t?i+="	*":i+="	|"});let o=[i,t.id,t.seq];for(let r in c.records.branches)c.records.branches.get(r)===t.id&&o.push(r);if(u.debug(o.join(" ")),t.parents&&t.parents.length==2&&t.parents[0]&&t.parents[1]){let r=c.records.commits.get(t.parents[0]);H(e,t,r),t.parents[1]&&e.push(c.records.commits.get(t.parents[1]))}else{if(t.parents.length==0)return;if(t.parents[0]){let r=c.records.commits.get(t.parents[0]);H(e,t,r)}}e=S(e,r=>r.id),z(e)}d(z,"prettyPrintCommitHistory");var ft=d(function(){u.debug(c.records.commits);let e=j()[0];z([e])},"prettyPrint"),ut=d(function(){c.reset(),ot()},"clear"),bt=d(function(){return[...c.records.branchConfig.values()].map((e,t)=>e.order!==null&&e.order!==void 0?e:{...e,order:parseFloat(`0.${t}`)}).sort((e,t)=>(e.order??0)-(t.order??0)).map(({name:e})=>({name:e}))},"getBranchesAsObjArray"),wt=d(function(){return c.records.branches},"getBranches"),Bt=d(function(){return c.records.commits},"getCommits"),j=d(function(){let e=[...c.records.commits.values()];return e.forEach(function(t){u.debug(t.id)}),e.sort((t,i)=>t.seq-i.seq),e},"getCommitsArray"),Et=d(function(){return c.records.currBranch},"getCurrentBranch"),Ct=d(function(){return c.records.direction},"getDirection"),Lt=d(function(){return c.records.head},"getHead"),W={commitType:x,getConfig:P,setDirection:mt,setOptions:lt,getOptions:$t,commit:gt,branch:yt,merge:pt,cherryPick:xt,checkout:D,prettyPrint:ft,clear:ut,getBranchesAsObjArray:bt,getBranches:wt,getCommits:Bt,getCommitsArray:j,getCurrentBranch:Et,getDirection:Ct,getHead:Lt,setAccTitle:tt,getAccTitle:Z,getAccDescription:X,setAccDescription:Q,setDiagramTitle:J,getDiagramTitle:V},kt=d((e,t)=>{U(e,t),e.dir&&t.setDirection(e.dir);for(let i of e.statements)Tt(i,t)},"populate"),Tt=d((e,t)=>{let i={Commit:d(o=>t.commit(Mt(o)),"Commit"),Branch:d(o=>t.branch(vt(o)),"Branch"),Merge:d(o=>t.merge(Pt(o)),"Merge"),Checkout:d(o=>t.checkout(Rt(o)),"Checkout"),CherryPicking:d(o=>t.cherryPick(It(o)),"CherryPicking")}[e.$type];i?i(e):u.error(`Unknown statement type: ${e.$type}`)},"parseStatement"),Mt=d(e=>({id:e.id,msg:e.message??"",type:e.type!==void 0?x[e.type]:x.NORMAL,tags:e.tags??void 0}),"parseCommit"),vt=d(e=>({name:e.name,order:e.order??0}),"parseBranch"),Pt=d(e=>({branch:e.branch,id:e.id??"",type:e.type!==void 0?x[e.type]:void 0,tags:e.tags??void 0}),"parseMerge"),Rt=d(e=>e.branch,"parseCheckout"),It=d(e=>({id:e.id,targetId:"",tags:e.tags?.length===0?void 0:e.tags,parent:e.parent}),"parseCherryPicking"),Gt={parse:d(async e=>{let t=await _("gitGraph",e);u.debug(t),kt(t,W)},"parse")},At=et(),B=At?.gitGraph,T=10,M=40,C=4,L=2,v=8,b=new Map,w=new Map,G=30,R=new Map,A=[],k=0,y="LR",Ot=d(()=>{b.clear(),w.clear(),R.clear(),k=0,A=[],y="LR"},"clear"),K=d(e=>{let t=document.createElementNS("http://www.w3.org/2000/svg","text");return(typeof e=="string"?e.split(/\\n|\n|<br\s*\/?>/gi):e).forEach(i=>{let o=document.createElementNS("http://www.w3.org/2000/svg","tspan");o.setAttributeNS("http://www.w3.org/XML/1998/namespace","xml:space","preserve"),o.setAttribute("dy","1em"),o.setAttribute("x","0"),o.setAttribute("class","row"),o.textContent=i.trim(),t.appendChild(o)}),t},"drawText"),F=d(e=>{let t,i,o;return y==="BT"?(i=d((r,a)=>r<=a,"comparisonFunc"),o=1/0):(i=d((r,a)=>r>=a,"comparisonFunc"),o=0),e.forEach(r=>{let a=y==="TB"||y=="BT"?w.get(r)?.y:w.get(r)?.x;a!==void 0&&i(a,o)&&(t=r,o=a)}),t},"findClosestParent"),qt=d(e=>{let t="",i=1/0;return e.forEach(o=>{let r=w.get(o).y;r<=i&&(t=o,i=r)}),t||void 0},"findClosestParentBT"),Ht=d((e,t,i)=>{let o=i,r=i,a=[];e.forEach(h=>{let n=t.get(h);if(!n)throw new Error(`Commit not found for key ${h}`);n.parents.length?(o=Nt(n),r=Math.max(o,r)):a.push(n),St(n,o)}),o=r,a.forEach(h=>{Dt(h,o,i)}),e.forEach(h=>{let n=t.get(h);if(n?.parents.length){let $=qt(n.parents);o=w.get($).y-M,o<=r&&(r=o);let m=b.get(n.branch).pos,l=o-T;w.set(n.id,{x:m,y:l})}})},"setParallelBTPos"),zt=d(e=>{let t=F(e.parents.filter(o=>o!==null));if(!t)throw new Error(`Closest parent not found for commit ${e.id}`);let i=w.get(t)?.y;if(i===void 0)throw new Error(`Closest parent position not found for commit ${e.id}`);return i},"findClosestParentPos"),Nt=d(e=>zt(e)+M,"calculateCommitPosition"),St=d((e,t)=>{let i=b.get(e.branch);if(!i)throw new Error(`Branch not found for commit ${e.id}`);let o=i.pos,r=t+T;return w.set(e.id,{x:o,y:r}),{x:o,y:r}},"setCommitPosition"),Dt=d((e,t,i)=>{let o=b.get(e.branch);if(!o)throw new Error(`Branch not found for commit ${e.id}`);let r=t+i,a=o.pos;w.set(e.id,{x:a,y:r})},"setRootPosition"),jt=d((e,t,i,o,r,a)=>{if(a===x.HIGHLIGHT)e.append("rect").attr("x",i.x-10).attr("y",i.y-10).attr("width",20).attr("height",20).attr("class",`commit ${t.id} commit-highlight${r%v} ${o}-outer`),e.append("rect").attr("x",i.x-6).attr("y",i.y-6).attr("width",12).attr("height",12).attr("class",`commit ${t.id} commit${r%v} ${o}-inner`);else if(a===x.CHERRY_PICK)e.append("circle").attr("cx",i.x).attr("cy",i.y).attr("r",10).attr("class",`commit ${t.id} ${o}`),e.append("circle").attr("cx",i.x-3).attr("cy",i.y+2).attr("r",2.75).attr("fill","#fff").attr("class",`commit ${t.id} ${o}`),e.append("circle").attr("cx",i.x+3).attr("cy",i.y+2).attr("r",2.75).attr("fill","#fff").attr("class",`commit ${t.id} ${o}`),e.append("line").attr("x1",i.x+3).attr("y1",i.y+1).attr("x2",i.x).attr("y2",i.y-5).attr("stroke","#fff").attr("class",`commit ${t.id} ${o}`),e.append("line").attr("x1",i.x-3).attr("y1",i.y+1).attr("x2",i.x).attr("y2",i.y-5).attr("stroke","#fff").attr("class",`commit ${t.id} ${o}`);else{let h=e.append("circle");if(h.attr("cx",i.x),h.attr("cy",i.y),h.attr("r",t.type===x.MERGE?9:10),h.attr("class",`commit ${t.id} commit${r%v}`),a===x.MERGE){let n=e.append("circle");n.attr("cx",i.x),n.attr("cy",i.y),n.attr("r",6),n.attr("class",`commit ${o} ${t.id} commit${r%v}`)}a===x.REVERSE&&e.append("path").attr("d",`M ${i.x-5},${i.y-5}L${i.x+5},${i.y+5}M${i.x-5},${i.y+5}L${i.x+5},${i.y-5}`).attr("class",`commit ${o} ${t.id} commit${r%v}`)}},"drawCommitBullet"),Wt=d((e,t,i,o)=>{if(t.type!==x.CHERRY_PICK&&(t.customId&&t.type===x.MERGE||t.type!==x.MERGE)&&B?.showCommitLabel){let r=e.append("g"),a=r.insert("rect").attr("class","commit-label-bkg"),h=r.append("text").attr("x",o).attr("y",i.y+25).attr("class","commit-label").text(t.id),n=h.node()?.getBBox();if(n&&(a.attr("x",i.posWithOffset-n.width/2-L).attr("y",i.y+13.5).attr("width",n.width+2*L).attr("height",n.height+2*L),y==="TB"||y==="BT"?(a.attr("x",i.x-(n.width+4*C+5)).attr("y",i.y-12),h.attr("x",i.x-(n.width+4*C)).attr("y",i.y+n.height-12)):h.attr("x",i.posWithOffset-n.width/2),B.rotateCommitLabel))if(y==="TB"||y==="BT")h.attr("transform","rotate(-45, "+i.x+", "+i.y+")"),a.attr("transform","rotate(-45, "+i.x+", "+i.y+")");else{let $=-7.5-(n.width+10)/25*9.5,m=10+n.width/25*8.5;r.attr("transform","translate("+$+", "+m+") rotate(-45, "+o+", "+i.y+")")}}},"drawCommitLabel"),Kt=d((e,t,i,o)=>{if(t.tags.length>0){let r=0,a=0,h=0,n=[];for(let $ of t.tags.reverse()){let m=e.insert("polygon"),l=e.append("circle"),g=e.append("text").attr("y",i.y-16-r).attr("class","tag-label").text($),s=g.node()?.getBBox();if(!s)throw new Error("Tag bbox not found");a=Math.max(a,s.width),h=Math.max(h,s.height),g.attr("x",i.posWithOffset-s.width/2),n.push({tag:g,hole:l,rect:m,yOffset:r}),r+=20}for(let{tag:$,hole:m,rect:l,yOffset:g}of n){let s=h/2,f=i.y-19.2-g;if(l.attr("class","tag-label-bkg").attr("points",`
      ${o-a/2-C/2},${f+L}  
      ${o-a/2-C/2},${f-L}
      ${i.posWithOffset-a/2-C},${f-s-L}
      ${i.posWithOffset+a/2+C},${f-s-L}
      ${i.posWithOffset+a/2+C},${f+s+L}
      ${i.posWithOffset-a/2-C},${f+s+L}`),m.attr("cy",f).attr("cx",o-a/2+C/2).attr("r",1.5).attr("class","tag-hole"),y==="TB"||y==="BT"){let p=o+g;l.attr("class","tag-label-bkg").attr("points",`
        ${i.x},${p+2}
        ${i.x},${p-2}
        ${i.x+T},${p-s-2}
        ${i.x+T+a+4},${p-s-2}
        ${i.x+T+a+4},${p+s+2}
        ${i.x+T},${p+s+2}`).attr("transform","translate(12,12) rotate(45, "+i.x+","+o+")"),m.attr("cx",i.x+C/2).attr("cy",p).attr("transform","translate(12,12) rotate(45, "+i.x+","+o+")"),$.attr("x",i.x+5).attr("y",p+3).attr("transform","translate(14,14) rotate(45, "+i.x+","+o+")")}}}},"drawCommitTags"),Ft=d(e=>{switch(e.customType??e.type){case x.NORMAL:return"commit-normal";case x.REVERSE:return"commit-reverse";case x.HIGHLIGHT:return"commit-highlight";case x.MERGE:return"commit-merge";case x.CHERRY_PICK:return"commit-cherry-pick";default:return"commit-normal"}},"getCommitClassType"),Ut=d((e,t,i,o)=>{let r={x:0,y:0};if(e.parents.length>0){let a=F(e.parents);if(a){let h=o.get(a)??r;return t==="TB"?h.y+M:t==="BT"?(o.get(e.id)??r).y-M:h.x+M}}else return t==="TB"?G:t==="BT"?(o.get(e.id)??r).y-M:0;return 0},"calculatePosition"),_t=d((e,t,i)=>{let o=y==="BT"&&i?t:t+T,r=y==="TB"||y==="BT"?o:b.get(e.branch)?.pos,a=y==="TB"||y==="BT"?b.get(e.branch)?.pos:o;if(a===void 0||r===void 0)throw new Error(`Position were undefined for commit ${e.id}`);return{x:a,y:r,posWithOffset:o}},"getCommitPosition"),N=d((e,t,i)=>{if(!B)throw new Error("GitGraph config not found");let o=e.append("g").attr("class","commit-bullets"),r=e.append("g").attr("class","commit-labels"),a=y==="TB"||y==="BT"?G:0,h=[...t.keys()],n=B?.parallelCommits??!1,$=d((l,g)=>{let s=t.get(l)?.seq,f=t.get(g)?.seq;return s!==void 0&&f!==void 0?s-f:0},"sortKeys"),m=h.sort($);y==="BT"&&(n&&Ht(m,t,a),m=m.reverse()),m.forEach(l=>{let g=t.get(l);if(!g)throw new Error(`Commit not found for key ${l}`);n&&(a=Ut(g,y,a,w));let s=_t(g,a,n);if(i){let f=Ft(g),p=g.customType??g.type,q=b.get(g.branch)?.index??0;jt(o,g,s,f,q,p),Wt(r,g,s,a),Kt(r,g,s,a)}y==="TB"||y==="BT"?w.set(g.id,{x:s.x,y:s.posWithOffset}):w.set(g.id,{x:s.posWithOffset,y:s.y}),a=y==="BT"&&n?a+M:a+M+T,a>k&&(k=a)})},"drawCommits"),Yt=d((e,t,i,o,r)=>{let a=(y==="TB"||y==="BT"?i.x<o.x:i.y<o.y)?t.branch:e.branch,h=d($=>$.branch===a,"isOnBranchToGetCurve"),n=d($=>$.seq>e.seq&&$.seq<t.seq,"isBetweenCommits");return[...r.values()].some($=>n($)&&h($))},"shouldRerouteArrow"),I=d((e,t,i=0)=>{let o=e+Math.abs(e-t)/2;if(i>5)return o;if(A.every(a=>Math.abs(a-o)>=10))return A.push(o),o;let r=Math.abs(e-t);return I(e,t-r/5,i+1)},"findLane"),Vt=d((e,t,i,o)=>{let r=w.get(t.id),a=w.get(i.id);if(r===void 0||a===void 0)throw new Error(`Commit positions not found for commits ${t.id} and ${i.id}`);let h=Yt(t,i,r,a,o),n="",$="",m=0,l=0,g=b.get(i.branch)?.index;i.type===x.MERGE&&t.id!==i.parents[0]&&(g=b.get(t.branch)?.index);let s;if(h){n="A 10 10, 0, 0, 0,",$="A 10 10, 0, 0, 1,",m=10,l=10;let f=r.y<a.y?I(r.y,a.y):I(a.y,r.y),p=r.x<a.x?I(r.x,a.x):I(a.x,r.x);y==="TB"?r.x<a.x?s=`M ${r.x} ${r.y} L ${p-m} ${r.y} ${$} ${p} ${r.y+l} L ${p} ${a.y-m} ${n} ${p+l} ${a.y} L ${a.x} ${a.y}`:(g=b.get(t.branch)?.index,s=`M ${r.x} ${r.y} L ${p+m} ${r.y} ${n} ${p} ${r.y+l} L ${p} ${a.y-m} ${$} ${p-l} ${a.y} L ${a.x} ${a.y}`):y==="BT"?r.x<a.x?s=`M ${r.x} ${r.y} L ${p-m} ${r.y} ${n} ${p} ${r.y-l} L ${p} ${a.y+m} ${$} ${p+l} ${a.y} L ${a.x} ${a.y}`:(g=b.get(t.branch)?.index,s=`M ${r.x} ${r.y} L ${p+m} ${r.y} ${$} ${p} ${r.y-l} L ${p} ${a.y+m} ${n} ${p-l} ${a.y} L ${a.x} ${a.y}`):r.y<a.y?s=`M ${r.x} ${r.y} L ${r.x} ${f-m} ${n} ${r.x+l} ${f} L ${a.x-m} ${f} ${$} ${a.x} ${f+l} L ${a.x} ${a.y}`:(g=b.get(t.branch)?.index,s=`M ${r.x} ${r.y} L ${r.x} ${f+m} ${$} ${r.x+l} ${f} L ${a.x-m} ${f} ${n} ${a.x} ${f-l} L ${a.x} ${a.y}`)}else n="A 20 20, 0, 0, 0,",$="A 20 20, 0, 0, 1,",m=20,l=20,y==="TB"?(r.x<a.x&&(i.type===x.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${r.x} ${a.y-m} ${n} ${r.x+l} ${a.y} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${$} ${a.x} ${r.y+l} L ${a.x} ${a.y}`),r.x>a.x&&(n="A 20 20, 0, 0, 0,",$="A 20 20, 0, 0, 1,",m=20,l=20,i.type===x.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${r.x} ${a.y-m} ${$} ${r.x-l} ${a.y} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${a.x+m} ${r.y} ${n} ${a.x} ${r.y+l} L ${a.x} ${a.y}`),r.x===a.x&&(s=`M ${r.x} ${r.y} L ${a.x} ${a.y}`)):y==="BT"?(r.x<a.x&&(i.type===x.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${r.x} ${a.y+m} ${$} ${r.x+l} ${a.y} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${n} ${a.x} ${r.y-l} L ${a.x} ${a.y}`),r.x>a.x&&(n="A 20 20, 0, 0, 0,",$="A 20 20, 0, 0, 1,",m=20,l=20,i.type===x.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${r.x} ${a.y+m} ${n} ${r.x-l} ${a.y} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${n} ${a.x} ${r.y-l} L ${a.x} ${a.y}`),r.x===a.x&&(s=`M ${r.x} ${r.y} L ${a.x} ${a.y}`)):(r.y<a.y&&(i.type===x.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${$} ${a.x} ${r.y+l} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${r.x} ${a.y-m} ${n} ${r.x+l} ${a.y} L ${a.x} ${a.y}`),r.y>a.y&&(i.type===x.MERGE&&t.id!==i.parents[0]?s=`M ${r.x} ${r.y} L ${a.x-m} ${r.y} ${n} ${a.x} ${r.y-l} L ${a.x} ${a.y}`:s=`M ${r.x} ${r.y} L ${r.x} ${a.y+m} ${$} ${r.x+l} ${a.y} L ${a.x} ${a.y}`),r.y===a.y&&(s=`M ${r.x} ${r.y} L ${a.x} ${a.y}`));if(s===void 0)throw new Error("Line definition not found");e.append("path").attr("d",s).attr("class","arrow arrow"+g%v)},"drawArrow"),Jt=d((e,t)=>{let i=e.append("g").attr("class","commit-arrows");[...t.keys()].forEach(o=>{let r=t.get(o);r.parents&&r.parents.length>0&&r.parents.forEach(a=>{Vt(i,t.get(a),r,t)})})},"drawArrows"),Qt=d((e,t)=>{let i=e.append("g");t.forEach((o,r)=>{let a=r%v,h=b.get(o.name)?.pos;if(h===void 0)throw new Error(`Position not found for branch ${o.name}`);let n=i.append("line");n.attr("x1",0),n.attr("y1",h),n.attr("x2",k),n.attr("y2",h),n.attr("class","branch branch"+a),y==="TB"?(n.attr("y1",G),n.attr("x1",h),n.attr("y2",k),n.attr("x2",h)):y==="BT"&&(n.attr("y1",k),n.attr("x1",h),n.attr("y2",G),n.attr("x2",h)),A.push(h);let $=o.name,m=K($),l=i.insert("rect"),g=i.insert("g").attr("class","branchLabel").insert("g").attr("class","label branch-label"+a);g.node().appendChild(m);let s=m.getBBox();l.attr("class","branchLabelBkg label"+a).attr("rx",4).attr("ry",4).attr("x",-s.width-4-(B?.rotateCommitLabel===!0?30:0)).attr("y",-s.height/2+8).attr("width",s.width+18).attr("height",s.height+4),g.attr("transform","translate("+(-s.width-14-(B?.rotateCommitLabel===!0?30:0))+", "+(h-s.height/2-1)+")"),y==="TB"?(l.attr("x",h-s.width/2-10).attr("y",0),g.attr("transform","translate("+(h-s.width/2-5)+", 0)")):y==="BT"?(l.attr("x",h-s.width/2-10).attr("y",k),g.attr("transform","translate("+(h-s.width/2-5)+", "+k+")")):l.attr("transform","translate(-19, "+(h-s.height/2)+")")})},"drawBranches"),Xt=d(function(e,t,i,o,r){return b.set(e,{pos:t,index:i}),t+=50+(r?40:0)+(y==="TB"||y==="BT"?o.width/2:0),t},"setBranchPosition"),Zt=d(function(e,t,i,o){if(Ot(),u.debug("in gitgraph renderer",e+`
`,"id:",t,i),!B)throw new Error("GitGraph config not found");let r=B.rotateCommitLabel??!1,a=o.db;R=a.getCommits();let h=a.getBranchesAsObjArray();y=a.getDirection();let n=rt(`[id="${t}"]`),$=0;h.forEach((m,l)=>{let g=K(m.name),s=n.append("g"),f=s.insert("g").attr("class","branchLabel"),p=f.insert("g").attr("class","label branch-label");p.node()?.appendChild(g);let q=g.getBBox();$=Xt(m.name,$,l,q,r),p.remove(),f.remove(),s.remove()}),N(n,R,!1),B.showBranches&&Qt(n,h),Jt(n,R),N(n,R,!0),at.insertTitle(n,"gitTitleText",B.titleTopMargin??0,a.getDiagramTitle()),it(void 0,n,B.diagramPadding,B.useMaxWidth)},"draw"),te={draw:Zt},ee=d(e=>`
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0,1,2,3,4,5,6,7].map(t=>`
        .branch-label${t} { fill: ${e["gitBranchLabel"+t]}; }
        .commit${t} { stroke: ${e["git"+t]}; fill: ${e["git"+t]}; }
        .commit-highlight${t} { stroke: ${e["gitInv"+t]}; fill: ${e["gitInv"+t]}; }
        .label${t}  { fill: ${e["git"+t]}; }
        .arrow${t} { stroke: ${e["git"+t]}; }
        `).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${e.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelColor};}
  .commit-label-bkg { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${e.tagLabelFontSize}; fill: ${e.tagLabelColor};}
  .tag-label-bkg { fill: ${e.tagLabelBackground}; stroke: ${e.tagLabelBorder}; }
  .tag-hole { fill: ${e.textColor}; }

  .commit-merge {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }
  .commit-reverse {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
`,"getStyles"),re=ee,he={parser:Gt,db:W,renderer:te,styles:re};export{he as diagram};
