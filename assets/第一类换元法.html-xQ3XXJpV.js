import{_ as a,c as t,b as n,o as m}from"./app-hwWD7-tn.js";const e={};function p(l,s){return m(),t("div",null,s[0]||(s[0]=[n('<h1 id="省流版" tabindex="-1"><a class="header-anchor" href="#省流版"><span>省流版</span></a></h1><p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 为可积函数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g=g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 为连续可导函数，则有：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mo>∫</mo><mi>α</mi><mi>β</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>d</mi><mi>x</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mi>d</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">\\int^\\beta_\\alpha f(g)g&#39;{d}x = \\int^{g(\\beta)}_{g(\\alpha)} f(g){d}g </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.511em;vertical-align:-0.9119em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.599em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.7248em;vertical-align:-1.0869em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6379em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0869em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">d</span></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span></span></p><p>第一类换元法的基本思想是把被积函数的部分配凑到微分内。</p><p><mark>重点</mark>: 谁来当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>? 各类函数的优先级顺序:</p><ol><li>反三角函数</li><li>对数函数</li><li>幂函数</li><li>三角函数</li><li>指数函数</li></ol><hr><h1 id="废话版" tabindex="-1"><a class="header-anchor" href="#废话版"><span>废话版</span></a></h1><p><strong>第一类换元法</strong></p><p>第一类换元法是用于求解不定积分的一种常见技巧。它通过引入一个新的变量来将原始被积函数转换为一个更容易积分的形式。</p><p><strong>步骤</strong>：</p><ol><li><strong>选择新的变量</strong>：选择一个新的变量，通常用 u 或 t 来代替原来的自变量。这个新的变量将有助于简化被积函数。</li><li><strong>确定微分元素</strong>：计算新的变量 u 对于原来的自变量 x 的微分元素 du/dx，并得到 dx。</li><li><strong>代换</strong>：用新的变量 u 来代替原来的自变量 x，同时用 du/dx 和 dx 替换 du，将原来的被积函数转换为 u 的表达式。</li><li><strong>求不定积分</strong>：在新的变量 u 下求解积分，得到不定积分 ∫F(u) du。</li><li><strong>代回原变量</strong>：将 u 的表达式换回 x，得到最终的不定积分 ∫f(x) dx。</li></ol><p><strong>示例</strong>： 考虑不定积分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mn>2</mn><mi>x</mi><msup><mi>e</mi><msup><mi>x</mi><mn>2</mn></msup></msup><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">∫2x e^{x^2} dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.293em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span>。我们可以通过第一类换元法进行求解。</p><ol><li><strong>选择新的变量</strong>：令 u = x^2。</li><li><strong>确定微分元素</strong>：计算 du/dx = 2x，从中得到 dx = du/(2x)。</li><li><strong>代换</strong>：将 x^2 替换为 u，将 dx 替换为 du/(2x)，得到 ∫2x e^u (du/(2x))。</li><li><strong>求不定积分</strong>：在新的变量 u 下进行积分，得到 ∫e^u du = e^u + C，其中 C 是常数。</li><li><strong>代回原变量</strong>：将 u = x^2 代回，得到最终的不定积分 ∫2x e<sup>(x</sup>2) dx = e<sup>(x</sup>2) + C。</li></ol><p>因此，原不定积分 ∫2x e<sup>(x</sup>2) dx 等于 e<sup>(x</sup>2) 加上常数 C。</p>',15)]))}const r=a(e,[["render",p],["__file","第一类换元法.html.vue"]]),o=JSON.parse('{"path":"/%E5%BE%AE%E7%A7%AF%E5%88%86/%E7%A7%AF%E5%88%86/%E7%AC%AC%E4%B8%80%E7%B1%BB%E6%8D%A2%E5%85%83%E6%B3%95.html","title":"省流版","lang":"zh-CN","frontmatter":{"tags":["数学"],"dlink":["[[---积分---]]"],"author":"Cyletix","description":"省流版 设 f(x) 为可积函数，g=g(x) 为连续可导函数，则有： ∫αβ​f(g)g′dx=∫g(α)g(β)​f(g)dg 第一类换元法的基本思想是把被积函数的部分配凑到微分内。 重点: 谁来当g? 各类函数的优先级顺序: 反三角函数 对数函数 幂函数 三角函数 指数函数 废话版 第一类换元法 第一类换元法是用于求解不定积分的一种常见技巧。它通...","head":[["meta",{"property":"og:url","content":"https://PKM-er.github.io/Pkmer-Math/%E5%BE%AE%E7%A7%AF%E5%88%86/%E7%A7%AF%E5%88%86/%E7%AC%AC%E4%B8%80%E7%B1%BB%E6%8D%A2%E5%85%83%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Pkmer-Math"}],["meta",{"property":"og:title","content":"省流版"}],["meta",{"property":"og:description","content":"省流版 设 f(x) 为可积函数，g=g(x) 为连续可导函数，则有： ∫αβ​f(g)g′dx=∫g(α)g(β)​f(g)dg 第一类换元法的基本思想是把被积函数的部分配凑到微分内。 重点: 谁来当g? 各类函数的优先级顺序: 反三角函数 对数函数 幂函数 三角函数 指数函数 废话版 第一类换元法 第一类换元法是用于求解不定积分的一种常见技巧。它通..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-20T16:40:57.000Z"}],["meta",{"property":"article:author","content":"Cyletix"}],["meta",{"property":"article:tag","content":"数学"}],["meta",{"property":"article:modified_time","content":"2025-02-20T16:40:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"省流版\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-20T16:40:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Cyletix\\"}]}"]]},"headers":[{"level":1,"title":"省流版","slug":"省流版","link":"#省流版","children":[]},{"level":1,"title":"废话版","slug":"废话版","link":"#废话版","children":[]}],"git":{"createdTime":1740069657000,"updatedTime":1740069657000,"contributors":[{"name":"Cyletix","username":"Cyletix","email":"1016120209@qq.com","commits":1,"url":"https://github.com/Cyletix"}]},"readingTime":{"minutes":1.74,"words":522},"filePathRelative":"微积分/积分/第一类换元法.md","localizedDate":"2025年2月20日","excerpt":"\\n<p>设 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>f</mi><mo stretchy=\\"false\\">(</mo><mi>x</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">f(x)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.10764em;\\">f</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">x</span><span class=\\"mclose\\">)</span></span></span></span> 为可积函数，<span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>g</mi><mo>=</mo><mi>g</mi><mo stretchy=\\"false\\">(</mo><mi>x</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">g=g(x)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.625em;vertical-align:-0.1944em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.03588em;\\">g</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span><span class=\\"mrel\\">=</span><span class=\\"mspace\\" style=\\"margin-right:0.2778em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.03588em;\\">g</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">x</span><span class=\\"mclose\\">)</span></span></span></span> 为连续可导函数，则有：</p>","autoDesc":true,"bioChainData":{"outlink":[],"backlink":[{"title":"---积分---","link":"微积分/积分/---积分---.html"}],"localMap":{"nodes":[{"id":"微积分/积分/第一类换元法.md","value":{"title":"第一类换元法","path":"微积分/积分/第一类换元法.md","outlink":[],"backlink":["微积分/积分/---积分---.md"]}},{"id":"微积分/积分/---积分---.md","value":{"title":"---积分---","path":"微积分/积分/---积分---.md","outlink":[],"backlink":[]}}],"links":[{"source":"微积分/积分/---积分---.md","target":"微积分/积分/第一类换元法.md"}]}}}');export{r as comp,o as data};
