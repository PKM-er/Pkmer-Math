import{f as M}from"./chunk-CCU7O4O5-HpC12Rv2.js";import{m as k}from"./chunk-EYG76IYJ-CxqabO2R.js";import{m as p,bw as Y,bx as j,by as H,bz as _,p as a,a as $,bA as z,bB as Q,be as W,bC as Z,bk as q,bf as D,bd as K,bD as U,bE as V}from"./mermaid.esm.min-BSfDFYIg.js";import{s as N,_ as ee,J as G}from"./chunk-OMTJKCYW-DVfjqg3Y.js";import"./app-C2lKiqns.js";function w(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:J(e),edges:P(e)};return N(e.graph())||(n.value=ee(e.graph())),n}p(w,"write");function J(e){return G(e.nodes(),function(n){var r=e.node(n),s=e.parent(n),i={v:n};return N(r)||(i.value=r),N(s)||(i.parent=s),i})}p(J,"writeNodes");function P(e){return G(e.edges(),function(n){var r=e.edge(n),s={v:n.v,w:n.w};return N(n.name)||(s.name=n.name),N(r)||(s.value=r),s})}p(P,"writeEdges");var o=new Map,X=new Map,B=new Map,re=p(()=>{X.clear(),B.clear(),o.clear()},"clear"),I=p((e,n)=>{let r=X.get(n)||[];return a.trace("In isDescendant",n," ",e," = ",r.includes(e)),r.includes(e)},"isDescendant"),ne=p((e,n)=>{let r=X.get(n)||[];return a.info("Descendants of ",n," is ",r),a.info("Edge is ",e),e.v===n||e.w===n?!1:r?r.includes(e.v)||I(e.v,n)||I(e.w,n)||r.includes(e.w):(a.debug("Tilt, ",n,",not in descendants"),!1)},"edgeInCluster"),A=p((e,n,r,s)=>{a.warn("Copying children of ",e,"root",s,"data",n.node(e),s);let i=n.children(e)||[];e!==s&&i.push(e),a.warn("Copying (nodes) clusterId",e,"nodes",i),i.forEach(d=>{if(n.children(d).length>0)A(d,n,r,s);else{let l=n.node(d);a.info("cp ",d," to ",s," with parent ",e),r.setNode(d,l),s!==n.parent(d)&&(a.warn("Setting parent",d,n.parent(d)),r.setParent(d,n.parent(d))),e!==s&&d!==e?(a.debug("Setting parent",d,e),r.setParent(d,e)):(a.info("In copy ",e,"root",s,"data",n.node(e),s),a.debug("Not Setting parent for node=",d,"cluster!==rootId",e!==s,"node!==clusterId",d!==e));let g=n.edges(d);a.debug("Copying Edges",g),g.forEach(u=>{a.info("Edge",u);let f=n.edge(u.v,u.w,u.name);a.info("Edge data",f,s);try{ne(u,s)?(a.info("Copying as ",u.v,u.w,f,u.name),r.setEdge(u.v,u.w,f,u.name),a.info("newGraph edges ",r.edges(),r.edge(r.edges()[0]))):a.info("Skipping copy of edge ",u.v,"-->",u.w," rootId: ",s," clusterId:",e)}catch(m){a.error(m)}})}a.debug("Removing node",d),n.removeNode(d)})},"copy"),T=p((e,n)=>{let r=n.children(e),s=[...r];for(let i of r)B.set(i,e),s=[...s,...T(i,n)];return s},"extractDescendants"),te=p((e,n,r)=>{let s=e.edges().filter(g=>g.v===n||g.w===n),i=e.edges().filter(g=>g.v===r||g.w===r),d=s.map(g=>({v:g.v===n?r:g.v,w:g.w===n?n:g.w})),l=i.map(g=>({v:g.v,w:g.w}));return d.filter(g=>l.some(u=>g.v===u.v&&g.w===u.w))},"findCommonEdges"),C=p((e,n,r)=>{let s=n.children(e);if(a.trace("Searching children of id ",e,s),s.length<1)return e;let i;for(let d of s){let l=C(d,n,r),g=te(n,r,l);if(l)if(g.length>0)i=l;else return l}return i},"findNonClusterChild"),O=p(e=>!o.has(e)||!o.get(e).externalConnections?e:o.has(e)?o.get(e).id:e,"getAnchorId"),ae=p((e,n)=>{if(!e||n>10){a.debug("Opting out, no graph ");return}else a.debug("Opting in, graph ");e.nodes().forEach(function(r){e.children(r).length>0&&(a.warn("Cluster identified",r," Replacement id in edges: ",C(r,e,r)),X.set(r,T(r,e)),o.set(r,{id:C(r,e,r),clusterData:e.node(r)}))}),e.nodes().forEach(function(r){let s=e.children(r),i=e.edges();s.length>0?(a.debug("Cluster identified",r,X),i.forEach(d=>{let l=I(d.v,r),g=I(d.w,r);l^g&&(a.warn("Edge: ",d," leaves cluster ",r),a.warn("Descendants of XXX ",r,": ",X.get(r)),o.get(r).externalConnections=!0)})):a.debug("Not a cluster ",r,X)});for(let r of o.keys()){let s=o.get(r).id,i=e.parent(s);i!==r&&o.has(i)&&!o.get(i).externalConnections&&(o.get(r).id=i)}e.edges().forEach(function(r){let s=e.edge(r);a.warn("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(r)),a.warn("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(e.edge(r)));let i=r.v,d=r.w;if(a.warn("Fix XXX",o,"ids:",r.v,r.w,"Translating: ",o.get(r.v)," --- ",o.get(r.w)),o.get(r.v)||o.get(r.w)){if(a.warn("Fixing and trying - removing XXX",r.v,r.w,r.name),i=O(r.v),d=O(r.w),e.removeEdge(r.v,r.w,r.name),i!==r.v){let l=e.parent(i);o.get(l).externalConnections=!0,s.fromCluster=r.v}if(d!==r.w){let l=e.parent(d);o.get(l).externalConnections=!0,s.toCluster=r.w}a.warn("Fix Replacing with XXX",i,d,r.name),e.setEdge(i,d,s,r.name)}}),a.warn("Adjusted Graph",w(e)),R(e,0),a.trace(o)},"adjustClustersAndEdges"),R=p((e,n)=>{if(a.warn("extractor - ",n,w(e),e.children("D")),n>10){a.error("Bailing out");return}let r=e.nodes(),s=!1;for(let i of r){let d=e.children(i);s=s||d.length>0}if(!s){a.debug("Done, no node has children",e.nodes());return}a.debug("Nodes = ",r,n);for(let i of r)if(a.debug("Extracting node",i,o,o.has(i)&&!o.get(i).externalConnections,!e.parent(i),e.node(i),e.children("D")," Depth ",n),!o.has(i))a.debug("Not a cluster",i,n);else if(!o.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){a.warn("Cluster without external connections, without a parent and with children",i,n);let d=e.graph().rankdir==="TB"?"LR":"TB";o.get(i)?.clusterData?.dir&&(d=o.get(i).clusterData.dir,a.warn("Fixing dir",o.get(i).clusterData.dir,d));let l=new k({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});a.warn("Old graph before copy",w(e)),A(i,e,l,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:o.get(i).clusterData,label:o.get(i).label,graph:l}),a.warn("New graph after copy node: (",i,")",w(l)),a.debug("Old graph after copy",w(e))}else a.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!o.get(i).externalConnections," no parent: ",!e.parent(i)," children ",e.children(i)&&e.children(i).length>0,e.children("D"),n),a.debug(o);r=e.nodes(),a.warn("New list of nodes",r);for(let i of r){let d=e.node(i);a.warn(" Now next level",i,d),d?.clusterNode&&R(d.graph,n+1)}},"extractor"),L=p((e,n)=>{if(n.length===0)return[];let r=Object.assign([],n);return n.forEach(s=>{let i=e.children(s),d=L(e,i);r=[...r,...d]}),r},"sorter"),ie=p(e=>L(e,e.children()),"sortNodesByHierarchy"),F=p(async(e,n,r,s,i,d)=>{a.warn("Graph in recursive render:XAX",w(n),i);let l=n.graph().rankdir;a.trace("Dir in recursive render - dir:",l);let g=e.insert("g").attr("class","root");n.nodes()?a.info("Recursive render XXX",n.nodes()):a.info("No nodes found for",n),n.edges().length>0&&a.info("Recursive edges",n.edge(n.edges()[0]));let u=g.insert("g").attr("class","clusters"),f=g.insert("g").attr("class","edgePaths"),m=g.insert("g").attr("class","edgeLabels"),y=g.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(c){let t=n.node(c);if(i!==void 0){let h=JSON.parse(JSON.stringify(i.clusterData));a.trace(`Setting data for parent cluster XXX
 Node.id = `,c,`
 data=`,h.height,`
Parent cluster`,i.height),n.setNode(i.id,h),n.parent(c)||(a.trace("Setting parent",c,i.id),n.setParent(c,i.id,h))}if(a.info("(Insert) Node XXX"+c+": "+JSON.stringify(n.node(c))),t?.clusterNode){a.info("Cluster identified XBX",c,t.width,n.node(c));let{ranksep:h,nodesep:b}=n.graph();t.graph.setGraph({...t.graph.graph(),ranksep:h+25,nodesep:b});let E=await F(y,t.graph,r,s,n.node(c),d),S=E.elem;z(t,S),t.diff=E.diff||0,a.info("New compound node after recursive render XAX",c,"width",t.width,"height",t.height),Q(S,t)}else n.children(c).length>0?(a.trace("Cluster - the non recursive path XBX",c,t.id,t,t.width,"Graph:",n),a.trace(C(t.id,n)),o.set(t.id,{id:C(t.id,n),node:t})):(a.trace("Node - the non recursive path XAX",c,y,n.node(c),l),await W(y,n.node(c),{config:d,dir:l}))})),await p(async()=>{let c=n.edges().map(async function(t){let h=n.edge(t.v,t.w,t.name);a.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),a.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(n.edge(t))),a.info("Fix",o,"ids:",t.v,t.w,"Translating: ",o.get(t.v),o.get(t.w)),await Z(m,h)});await Promise.all(c)},"processEdges")(),a.info("Graph before layout:",JSON.stringify(w(n))),a.info("############################################# XXX"),a.info("###                Layout                 ### XXX"),a.info("############################################# XXX"),M(n),a.info("Graph after layout:",JSON.stringify(w(n)));let v=0,{subGraphTitleTotalMargin:x}=q(d);return await Promise.all(ie(n).map(async function(c){let t=n.node(c);if(a.info("Position XBX => "+c+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t?.clusterNode)t.y+=x,a.info("A tainted cluster node XBX1",c,t.id,t.width,t.height,t.x,t.y,n.parent(c)),o.get(t.id).node=t,D(t);else if(n.children(c).length>0){a.info("A pure cluster node XBX1",c,t.id,t.x,t.y,t.width,t.height,n.parent(c)),t.height+=x,n.node(t.parentId);let h=t?.padding/2||0,b=t?.labelBBox?.height||0,E=b-h||0;a.debug("OffsetY",E,"labelHeight",b,"halfPadding",h),await K(u,t),o.get(t.id).node=t}else{let h=n.node(t.parentId);t.y+=x/2,a.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",h,h?.offsetY,t),D(t)}})),n.edges().forEach(function(c){let t=n.edge(c);a.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(t),t),t.points.forEach(S=>S.y+=x/2);let h=n.node(c.v);var b=n.node(c.w);let E=U(f,t,o,r,h,b,s);V(t,E)}),n.nodes().forEach(function(c){let t=n.node(c);a.info(c,t.type,t.diff),t.isGroup&&(v=t.diff)}),a.warn("Returning from recursive render XAX",g,v),{elem:g,diff:v}},"recursiveRender"),ce=p(async(e,n)=>{let r=new k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),s=n.select("g");Y(s,e.markers,e.type,e.diagramId),j(),H(),_(),re(),e.nodes.forEach(d=>{r.setNode(d.id,{...d}),d.parentId&&r.setParent(d.id,d.parentId)}),a.debug("Edges:",e.edges),e.edges.forEach(d=>{if(d.start===d.end){let l=d.start,g=l+"---"+l+"---1",u=l+"---"+l+"---2",f=r.node(l);r.setNode(g,{domId:g,id:g,parentId:f.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),r.setParent(g,f.parentId),r.setNode(u,{domId:u,id:u,parentId:f.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),r.setParent(u,f.parentId);let m=structuredClone(d),y=structuredClone(d),v=structuredClone(d);m.label="",m.arrowTypeEnd="none",m.id=l+"-cyclic-special-1",y.arrowTypeStart="none",y.arrowTypeEnd="none",y.id=l+"-cyclic-special-mid",v.label="",f.isGroup&&(m.fromCluster=l,v.toCluster=l),v.id=l+"-cyclic-special-2",v.arrowTypeStart="none",r.setEdge(l,g,m,l+"-cyclic-special-0"),r.setEdge(g,u,y,l+"-cyclic-special-1"),r.setEdge(u,l,v,l+"-cyc<lic-special-2")}else r.setEdge(d.start,d.end,{...d},d.id)}),a.warn("Graph at first:",JSON.stringify(w(r))),ae(r),a.warn("Graph after XAX:",JSON.stringify(w(r)));let i=$();await F(s,r,e.type,e.diagramId,void 0,i)},"render");export{ce as render};
